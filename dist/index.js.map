{"version":3,"sources":["../src/services/aithraService.ts","../src/actions/createMusicPlaylist.ts","../src/helpers.ts","../src/environment.ts","../src/services/paymentService.ts","../src/storage.ts","../src/plugins/aithraToolkitPlugin.ts","../src/index.ts"],"sourcesContent":["import {\n    IAgentRuntime,\n    Service,\n    ServiceType,\n} from \"@elizaos/core\";\nimport { Connection, Keypair } from \"@solana/web3.js\";\nimport { AithraManager, TrackInfo, BuildMusicNFTResult } from \"@aithranetwork/sdk-aithra-toolkit\";\nimport bs58 from \"bs58\";\nimport * as fs from \"fs\";\nimport * as os from \"os\";\nimport * as path from \"path\";\n\nexport class AithraService extends Service {\n    private manager: AithraManager;\n    private connection: Connection;\n    private keypair: Keypair;\n    private basePath: string;\n    private items = 0;\n\n    constructor() {\n        super();\n    }\n\n    getBasePath(): string {\n        return this.basePath;\n    }\n\n    private removeAndCreateAssetsFolder(): void {\n        const assetsPath = path.join(this.basePath, \"assets\");\n        fs.rmSync(assetsPath, { recursive: true, force: true });\n        fs.mkdirSync(assetsPath, { recursive: true });\n        for (const folder of [\"audio\", \"images\"]) {\n            fs.mkdirSync(path.join(assetsPath, folder), { recursive: true });\n        }\n    }\n\n    private readTrackInfo(): TrackInfo {\n        const infoPath = path.join(this.basePath, \"assets\", \"info.json\");\n        if (!fs.existsSync(infoPath)) return [];\n        const existingInfo = fs.readFileSync(infoPath, \"utf8\");\n        return JSON.parse(existingInfo) as TrackInfo;\n    }\n\n    private writeTrackInfo(trackInfo: TrackInfo): void {\n        const infoPath = path.join(this.basePath, \"assets\", \"info.json\");\n        fs.writeFileSync(infoPath, JSON.stringify(trackInfo, null, 2));\n    }\n\n    private createTempFolderStructure(): void {\n        try {\n            this.removeAndCreateAssetsFolder();\n        } catch (err) {\n            console.error(\"Failed to create assets folder structure:\", err);\n        }\n    }\n\n    static get serviceType() {\n        return \"aithra_toolkit\" as ServiceType;\n    }\n\n\n    async getTotalCost(numberOfSongs:number, numberOfMints:number): Promise<number> {\n        const response =  await this.manager.getTotalCost(numberOfSongs, numberOfMints);\n        \n       if (response.isOk()){\n              return response.unwrap();\n       }\n\n\n    }\n\n    async initialize(runtime: IAgentRuntime, basePath?: string): Promise<void> {\n        this.connection = new Connection(\n            runtime.getSetting(\"SOLANA_RPC_URL\") ||\n                \"https://api.mainnet-beta.solana.com\",\n            \"confirmed\"\n        );\n\n        const privateKey = runtime.getSetting(\"AITHRA_PRIVATE_KEY\");\n        if (!privateKey) {\n            throw new Error(\n                \"AITHRA_PRIVATE_KEY environment variable is required\"\n            );\n        }\n\n        this.keypair = Keypair.fromSecretKey(bs58.decode(privateKey));\n\n        // Initialize the AithraManager\n        this.manager = new AithraManager({\n            connection: this.connection,\n            keypair: this.keypair,\n            priorityFee:\n                Number(runtime.getSetting(\"AITHRA_PRIORITY_FEE\")) ||\n                Number(process.env.AITHRA_PRIORITY_FEE) ||\n                0,\n        });\n\n        this.basePath = path.resolve(\n            basePath || path.join(os.tmpdir(), \"aithra-temp\")\n        );\n\n        this.createTempFolderStructure();\n    }\n\n    async buildUploadMintMusicNFTs(params: {\n        playlist: {\n            name: string;\n            creator: string;\n        };\n        tokenCode: \"MUSIC\";\n        nft: {\n            tokenName: string;\n            sellerFeeBasisPoints: number;\n            quantity: number;\n            name: string;\n            description: string;\n        };\n        animation: {\n            animationFile: string;\n        };\n        creator?: string;\n    })\n    : Promise<BuildMusicNFTResult> {\n        try {\n            const result = await this.manager.buildUploadMintMusicNFTs({\n                folderPath: path.join(this.basePath, \"assets\"),\n                ...params,\n            });\n\n            fs.rmSync(path.join(this.basePath, \"assets\"), {\n                recursive: true,\n                force: true,\n            });\n\n            if (result.isOk()){\n                return result.unwrap(); \n            }\n        } catch (error) {\n            console.error(\"Failed to upload music NFTs:\", error);\n            throw error;\n        }\n    }\n\n    private storeBufferToFile(\n        buffer: Buffer,\n        subFolder: string,\n        fileName: string\n    ): string {\n        const filePath = path.join(\n            this.basePath,\n            \"assets\",\n            subFolder,\n            fileName\n        );\n        fs.writeFileSync(filePath, buffer);\n        return filePath;\n    }\n\n    private saveTrackData(\n        trackData: Buffer,\n        trackMetadata: {\n            artist: string;\n            album: string;\n            title: string;\n            category: string;\n        },\n        trackNumber: number\n    ): void {\n        this.storeBufferToFile(trackData, \"audio\", `track${trackNumber}.mp3`);\n        let trackInfo = this.readTrackInfo();\n        trackInfo.push({\n            [`track${trackNumber}`]: { metadata: trackMetadata },\n        });\n        this.writeTrackInfo(trackInfo);\n    }\n\n    storeTrackToFolder(params: {\n        track: {\n            data: Buffer;\n            metadata: {\n                artist: string;\n                album: string;\n                title: string;\n                category: string;\n            };\n            image: Buffer;\n            imageExtension?: string;\n        };\n    }): void {\n        this.items += 1;\n        this.saveTrackData(\n            params.track.data,\n            params.track.metadata,\n            this.items\n        );\n\n        if (params.track.image) {\n            this.storeBufferToFile(\n                params.track.image,\n                \"images\",\n                `track${this.items}_cover.${params.track.imageExtension || 'jpg'}`\n            );\n        }\n    }\n\n    storeTracksToFolder(params: {\n        tracks: Array<{\n            data: Buffer;\n            metadata: {\n                artist: string;\n                album: string;\n                title: string;\n                category: string;\n            };\n            image: Buffer;\n        }>;\n    }): void {\n        for (let i = 0; i < params.tracks.length; i++) {\n            this.storeTrackToFolder({\n                track: params.tracks[i],\n            });\n        }\n    }\n\n    storeAnimationToFolder(params: {\n        animation: Buffer;\n        extension?: string;\n    }): string {\n        return this.storeBufferToFile(\n            params.animation,\n            \"\",\n            `animation.${params.extension || \"png\"}`\n        );\n    }\n}\n","import { composeContext, Content, generateImage, generateObject, generateObjectDeprecated, HandlerCallback, IAgentRuntime, Media, Memory, ModelClass, ServiceType, State } from \"@elizaos/core\";\nimport { convertBase64ToBuffer, Description, generateAudio, SchemaGenerator } from \"../helpers\";\nimport {aithraToolkitLogger}  from \"@aithranetwork/sdk-aithra-toolkit\";\nimport { validateAithraConfig } from \"../environment\";\nimport { AithraService } from \"../services/aithraService\";\nimport { PaymentsService } from \"../services/paymentService\";\nimport { Action } from \"@elizaos/core\";\nimport { ActionExample } from \"@elizaos/core\";\n\n\n\n\nexport class MusicPlaylistDetails {\n    @Description(\"The release type of the music: EP | SINGLE | ALBUM\")\n    releaseType: \"EP\" | \"SINGLE\" | \"ALBUM\";\n\n    @Description(\"The title of the music release\")\n    title: string;\n\n    @Description(\"The style or genre of the music\")\n    style: string;\n\n    @Description(\"The wallet address to send the music to\")\n    walletAddress: string;\n\n    @Description(\"The transaction hash of the payment\")\n    paymentTxHash: string;\n\n    @Description(\"How many nfts to mint\")\n    numberOfMints: number = 1;\n\n    constructor(partial: Partial<MusicPlaylistDetails> = {}) {\n        Object.assign(this, {\n            releaseType: partial.releaseType,\n            title: partial.title,\n            style: partial.style,\n            walletAddress: partial.walletAddress,\n            paymentTxHash: partial.paymentTxHash,\n            numberOfMints: Number(partial.numberOfMints) || 1,\n        });\n    }\n}\n\n\nexport const extractPrompt = \n`\n    Extract info from this content:\n\n    {{recentMessages}}\n\n    {{output_format}}\n`;\n\nexport class GenerativePrompts { \n    @Description(\"Prompt used to generate the track cover image, at least 100 characters, required\")\n    coverImagePrompt: string;\n    @Description(\"Prompt used to generate the audio of the track, at least 100 characters, required\")\n    audioPrompt: string;\n    @Description(\"Lyrics with optional formatting. You can use a newline to separate each line of lyrics. You can use two newlines to add a pause between lines. You can use double hash marks (##) at the beginning and end of the lyrics to add accompaniment. Maximum 350 to 400 characters, required\")\n    lyrics: string;\n    @Description(\"Prompt used to generate the cover image of the NFT, at least 100 characters, required\")\n    nftCoverImagePrompt: string;\n    @Description(\"The description of the NFT, maximum 100 150 characters\")\n    nftDescription: string;\n    @Description(\"The name of the nft, should follow camelCase format starting with uppercase letter, max 28 characters\")\n    nftName: string;\n    @Description(\"The album title generated\")\n    albumTitle: string;\n\n    constructor(partial: Partial<GenerativePrompts> = {}) {\n        Object.assign(this, partial);\n    }\n}\n\n\nexport const generativePrompt = \n`\n    Based on the following information:\n\n    {{title}}\n\n    {{style}}\n    \n    {{output_format}}\n`;\n\n\nexport default {\n    name:\"CREATE_MUSIC_PLAYLIST\",\n    similes: [\"MINT_MUSIC_PLAYLIST\", 'GENERATE_MUSIC_PLAYLIST', 'CREATE_MUSIC_PLAYLIST'],\n    validate: async(runtime: IAgentRuntime, message:Memory)=>{\n        aithraToolkitLogger.info(\"Validating config for user:\", message.userId);\n        await validateAithraConfig(runtime);\n        return true;\n    },\n    description:\"Create a music playlist\",\n    handler: async (runtime:IAgentRuntime, message:Memory, state:State, _options: { [key: string]: unknown },\n        callback?: HandlerCallback) =>{\n        try {    \n            aithraToolkitLogger.info(\"Creating music playlist for user:\", message.userId);\n\n            const aithraService = runtime.getService(\"aithra_toolkit\" as ServiceType) as AithraService;\n\n            aithraService.initialize(runtime);\n            \n            state = (await runtime.composeState(message,{output_format: SchemaGenerator.generateJSONSchema(MusicPlaylistDetails)})) as State;\n\n            const context = composeContext({state,template:extractPrompt});\n\n            const content = await generateObjectDeprecated({\n                runtime,\n                context: context,\n                modelClass: ModelClass.LARGE,\n            });\n\n            const payload:MusicPlaylistDetails = new MusicPlaylistDetails(content);\n\n            // To be used in catch block\n            // to remove the payment if the minting fails\n            _options = {paymentHash:payload.paymentTxHash}\n            \n\n            // Verify payment \n\n            const totalCost = await aithraService.getTotalCost(1, payload.numberOfMints);\n\n            const paymentService = new PaymentsService(runtime.getSetting(\"SOLANA_RPC_URL\") as string,runtime); \n\n            const paymentCheckResponse = await paymentService.verifyEligiblePayment({paymentHash:payload.paymentTxHash, totalCost, walletAddress:payload.walletAddress});\n\n            if (paymentCheckResponse.isErr()){\n                \n                    if(callback){\n                        callback({\n                            text:`Payment verification failed: ${paymentCheckResponse.getErr().message}`,\n                            content:{error:paymentCheckResponse.getErr().message}\n                        })\n                    }\n                    return false;\n\n            }\n\n            state = (await runtime.composeState(message,{title:payload.title,style:payload.style,output_format: SchemaGenerator.generateJSONSchema(GenerativePrompts)})) as State;\n\n\n            const generativePromptsContext = composeContext({state,template:generativePrompt});\n\n            const generativePromptsContent = await generateObjectDeprecated({\n                runtime,\n                context: generativePromptsContext,\n                modelClass: ModelClass.LARGE,\n            });\n\n            const generativePromptsPayload: GenerativePrompts = new GenerativePrompts(generativePromptsContent);\n\n            const coverImageBase64 =  (await generateImage({\n                prompt: generativePromptsPayload.coverImagePrompt,\n                width: 512,\n                height: 512,\n                count: 1,\n            }, runtime as IAgentRuntime)).data[0];\n\n\n            const {buffer:coverImageBuffer, extension:coverImageExtension} = convertBase64ToBuffer(coverImageBase64);\n\n            const nftImageBase64 = (await generateImage({\n                prompt: generativePromptsPayload.nftCoverImagePrompt,\n                width: 512,\n                height: 512,\n                count: 1,\n            }, runtime as IAgentRuntime)).data[0];\n\n            const {buffer:nftImageBuffer, extension:nftImageExtension} = convertBase64ToBuffer(nftImageBase64);\n\n\n            if(callback){\n                callback({\n                    text:`Just finished generating the images`,\n                })\n            }\n\n           \n            const trackResponse = (await generateAudio({\n                lyrics: generativePromptsPayload.lyrics,\n            }, runtime as IAgentRuntime));\n\n            if (trackResponse.isErr()){\n                if(callback){\n                    callback({\n                        text:`Track generation failed: ${trackResponse.getErr().message}`,\n                        content:{error:trackResponse.getErr().message}\n                    })\n                }\n                return false;\n            }\n\n\n            if(callback){\n                callback({\n                    text:`Just finished generating the audio`,\n                })\n            }\n\n            const trackBuffer = trackResponse.unwrap();\n\n\n            aithraService.storeTrackToFolder({\n                track:{\n                    data:trackBuffer,\n                    metadata:{\n                        artist: \"Aithra\",\n                        title: payload.title,\n                        album: generativePromptsPayload.albumTitle,\n                        category: payload.style,\n                    },\n                    image: coverImageBuffer,\n                    imageExtension:coverImageExtension\n                }\n            })\n\n            const animationMediaPath = aithraService.storeAnimationToFolder({\n                animation:nftImageBuffer,\n                extension:nftImageExtension\n            })\n\n\n\n            if(callback){\n                callback({\n                    text:`Minting the music playlist now`,\n                })\n            }\n\n\n            const mintResponse = await aithraService.buildUploadMintMusicNFTs({\n                playlist:{\n                    name:`${payload.title} ${payload.releaseType}`,\n                    creator: \"Aithra\",\n                },\n                tokenCode:\"MUSIC\",\n                nft:{\n                    tokenName:`MUS${generativePromptsPayload.nftName}`,\n                    sellerFeeBasisPoints:50,\n                    quantity: Number(payload.numberOfMints),\n                    name:`MUS - ${generativePromptsPayload.nftName}`,\n                    description:generativePromptsPayload.nftDescription,\n                },\n                animation:{\n                    animationFile:animationMediaPath\n                },\n                creator: payload.walletAddress\n            })\n    \n\n\n            if (mintResponse.success){\n                if(callback){\n                    callback({\n                        text:`Music playlist minted successfully, ${payload.numberOfMints} NFTs minted. The asset ids are: ${mintResponse.assetIds}`,\n                        content:{success:true}\n                    })\n                }\n            }        \n            return true;\n        } catch (error) {\n\n            const paymentService = new PaymentsService(runtime.getSetting(\"SOLANA_RPC_URL\") as string,runtime); \n\n            const removeResponse = await paymentService.deletePayment(_options.paymentHash as string);\n\n            if (removeResponse.isErr()){\n                aithraToolkitLogger.error(\"Error removing the payment:\", removeResponse.getErr());\n            }\n\n            aithraToolkitLogger.error(\"Error creating the playlist:\", error);\n            if (callback) {\n                callback({\n                    text: `Issue with creating the playlist: ${error.message}; Payment can be reutilized`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    examples:[\n            [\n                {\n                    user:\"{{user1}}\",\n                    content:{\n                        text:\"hey can you create me a unique song EP titled 'Show me the money!' in the style of Hard Rock Music and send it to my wallet 8QL8tp2kC9ZSHjArSvqGfti6pUYVyGvpvR6WFNtUzcYc. Here is the SOL payment TX: 4SC6GgGfayfambZ7ufeGzGAgXiRTUnci5eeu76qWxaKxCtJrm8nBjyrkaVHe75JYrseEkmxGbxV7efDGUhhgCwu5\"\n                    }\n                },\n                {\n                    user:\"{{user1}}\",\n                    content:{\n                        text:\"Creating the music playlist for you now\",\n                        action:\"CREATE_MUSIC_PLAYLIST\"\n                    }\n                }\n            ]\n    ] as ActionExample[][],\n} as Action;","import 'reflect-metadata';\nimport Replicate from \"replicate\";\nimport {Result} from \"@aithranetwork/sdk-aithra-toolkit\";\nimport { IAgentRuntime } from '@elizaos/core';\n\nexport class SchemaField {\n    constructor(\n        public type: string,\n        public description?: string\n    ) {}\n}\n\nexport function Description(description: string) {\n    return function(target: any, propertyKey: string) {\n        Reflect.defineMetadata('description', description, target, propertyKey);\n    };\n}\n\nexport class SchemaGenerator {\n    static generateJSONSchema(classType: any): string {\n        const schema = this.parseClass(classType);\n        return this.convertToPrompt(schema);\n    }\n\n    private static parseClass(classType: any): Record<string, SchemaField> {\n        const schema: Record<string, SchemaField> = {};\n        const instance = new classType();\n        const prototype = Object.getPrototypeOf(instance);\n\n        for (const key of Object.keys(instance)) {\n            const type = Reflect.getMetadata('design:type', prototype, key);\n            const description = Reflect.getMetadata('description', instance, key);\n            const actualValue = instance[key];\n            \n            let typeString: string;\n            if (type === Array || Array.isArray(actualValue)) {\n                typeString = 'string[]'; // For this use case, we know we want string arrays\n            } else if (this.isNestedObject(actualValue)) {\n                typeString = this.parseNestedObject(actualValue);\n            } else {\n                typeString = this.getTypeString(type || actualValue?.constructor, actualValue);\n            }\n\n            schema[key] = new SchemaField(typeString, description);\n        }\n\n        return schema;\n    }\n\n    private static isNestedObject(value: any): boolean {\n        return value !== null && \n               typeof value === 'object' && \n               !Array.isArray(value) &&\n               Object.keys(value).length > 0;\n    }\n\n    private static parseNestedObject(obj: any): string {\n        let result = '{\\n';\n        for (const [key, value] of Object.entries(obj)) {\n            const type = typeof value;\n            result += `        ${key}: ${type},\\n`;\n        }\n        result += '    }';\n        return result;\n    }\n\n    private static getTypeString(type: any, value: any): string {\n        if (!type) return typeof value;\n\n        const typeName = type.name.toLowerCase();\n        switch (typeName) {\n            case 'string': return 'string';\n            case 'number': return 'number';\n            case 'boolean': return 'boolean';\n            case 'array': return 'string[]';\n            case 'object': return typeof value;\n            default: return type.name;\n        }\n    }\n\n    private static convertToPrompt(schema: Record<string, SchemaField>): string {\n        let prompt = 'Answer ONLY with JSON using this schema:\\n{\\n';\n\n        Object.entries(schema).forEach(([key, field]) => {\n            if (field.description) {\n                prompt += `  // ${field.description}\\n`;\n            }\n            const indent = field.type.includes('{\\n') ? '' : '  ';\n            prompt += `  ${key}: ${field.type},\\n`;\n        });\n\n        prompt += '}';\n        return prompt;\n    }\n}\n\n\n// const prompt = SchemaGenerator.generatePrompt(Receipt);\n// console.log(prompt);\n\n\n\n\n\n\n\n\n\nexport function convertBase64ToBuffer(base64String: string): { buffer: Buffer; extension: string } {\n    // Remove data URL prefix if present\n    const base64Data = base64String.replace(/^data:image\\/\\w+;base64,/, '');\n\n    // Get extension from data URL\n    const extension = base64String.split(';')[0]?.split('/')[1] || 'unknown';\n\n    // Convert to buffer\n    const buffer = Buffer.from(base64Data, 'base64');\n\n    return {\n      buffer,\n      extension\n    };\n  }\n\nexport async function generateAudio({\n    prompt,\n    lyrics,\n    referenceAudioUrl\n}: {\n    prompt?: string;\n    lyrics?: string;\n    referenceAudioUrl?: string;\n}, runtime: IAgentRuntime): Promise<Result<Buffer, Error>> {\n    try {\n        const replicate = new Replicate({\n            auth: runtime.getSetting(\"REPLICATE_API_TOKEN\"),\n        });\n\n        const input = {\n            lyrics: lyrics ?? \"[intro]\\n\\nUpload my heart to the digital sky\\nAlgorithm love, you make me feel so high\\nBinary kisses, ones and zeros fly (fly)\\nOoooh ooooh\\n\\n[chorus]\\nYour neural network's got me feeling so alive\",\n            bitrate: 256000,\n            song_file: referenceAudioUrl ?? \"https://raw.githubusercontent.com/Itheum/data-assets/main/Misc/1-dnandb-seimicpulse-a.mp3\",\n            sample_rate: 44100\n        };\n          \n        const response = await replicate.run(\"minimax/music-01\", { input });\n        \n     \n        if (response instanceof ReadableStream) {\n            const reader = response.getReader();\n            const chunks: Uint8Array[] = [];\n        \n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) break;\n                chunks.push(value);\n            }\n        \n            const audioBuffer = Buffer.concat(chunks.map(chunk => Buffer.from(chunk)));\n            return Result.ok(audioBuffer);\n        }\n    \n\n        return Result.err(new Error('Invalid response format from Replicate API'));\n    } catch (error) {\n        return Result.err(error instanceof Error ? error : new Error('Unknown error occurred while generating audio'));\n    }\n}\n","import { IAgentRuntime } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\nexport const aithraEnvSchema = z.object({\n    SOLANA_RPC_URL: z.string().min(1, \"Solana RPC URL is required\"),\n    AITHRA_PRIVATE_KEY: z.string().min(1, \"Aithra private key is required\"),\n    AITHRA_PRIORITY_FEE: z\n        .number()\n        .min(0, \"Priority fee must be a non-negative number\"),\n});\n\nexport type AithraConfig = z.infer<typeof aithraEnvSchema>;\n\nexport async function validateAithraConfig(\n    runtime: IAgentRuntime\n): Promise<AithraConfig> {\n    try {\n        const config = {\n            SOLANA_RPC_URL:\n                runtime.getSetting(\"SOLANA_RPC_URL\") ||\n                process.env.SOLANA_RPC_URL,\n            AITHRA_PRIVATE_KEY:\n                runtime.getSetting(\"AITHRA_PRIVATE_KEY\") ||\n                process.env.AITHRA_PRIVATE_KEY,\n            AITHRA_PRIORITY_FEE:\n                Number(runtime.getSetting(\"AITHRA_PRIORITY_FEE\")) ||\n                Number(process.env.AITHRA_PRIORITY_FEE),\n        };\n\n        return aithraEnvSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Aithra configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import { Connection, PublicKey,Keypair } from \"@solana/web3.js\";\nimport { getAssociatedTokenAddressSync } from \"@solana/spl-token\";\nimport { PaymentsStorage } from \"../storage\";\nimport { IAgentRuntime } from \"@elizaos/core\";\nimport { Result } from \"@aithranetwork/sdk-aithra-toolkit\";\nimport bs58 from \"bs58\";\n\nclass TransactionNotFoundError extends Error {\n    constructor() {\n        super(\"Transaction not found\");\n    }\n}\n\nclass TransferInstructionNotFoundError extends Error {\n    constructor() {\n        super(\"Transfer instruction not found in transaction\");\n    }\n}\n\ntype TransferDetails = {\n    receiver: string;\n    sender: string;\n    amount: string;\n};\n\nexport class PaymentsService {\n    private readonly rpcUrl: string;\n    private readonly paymentsStorage:PaymentsStorage;\n    private readonly AITHRA_MINT = new PublicKey(\n        'iTHSaXjdqFtcnLK4EFEs7mqYQbJb6B7GostqWbBQwaV'\n    );\n    private readonly walletPublicKey:string = '';\n\n    constructor(rpcUrl: string,runtime:IAgentRuntime) {\n        this.rpcUrl = rpcUrl;\n        this.paymentsStorage = new PaymentsStorage(runtime);\n\n        const privateKey = runtime.getSetting(\"AITHRA_PRIVATE_KEY\");\n        const keypair = Keypair.fromSecretKey(bs58.decode(privateKey));\n\n        this.walletPublicKey = keypair.publicKey.toBase58();\n\n\n    }\n\n\n    private async getSolTransferDetails(tx: string): Promise<Result<TransferDetails, Error>> {\n        try {\n            const connection = new Connection(this.rpcUrl, \"confirmed\");\n    \n            const transaction = await connection.getParsedTransaction(tx, {\n                maxSupportedTransactionVersion: 0,\n            });\n    \n            if (!transaction || transaction.meta?.err) {\n                return Result.err(new TransactionNotFoundError());\n            }\n    \n            const instructions = transaction.transaction.message.instructions;\n    \n            const transferInstruction = instructions.find((instruction) => {\n                if (\"parsed\" in instruction) {\n                    return instruction.program === \"system\" && instruction.parsed.type === \"transfer\";\n                }\n                return false;\n            });\n    \n            if (transferInstruction && \"parsed\" in transferInstruction) {\n                const { info } = transferInstruction.parsed;\n                if (\"destination\" in info && \"source\" in info) {\n                    return Result.ok({\n                        receiver: info.destination,\n                        sender: info.source,\n                        amount: (Number(info.lamports) / 1e9).toString(), // Convert lamports to SOL\n                    });\n                }\n            }\n    \n            return Result.err(new TransferInstructionNotFoundError());\n        } catch (error) {\n            return Result.err(error instanceof Error ? error : new Error(String(error)));\n        }\n    }\n\n\n    private async getSplTransferDetails(tx: string): Promise<Result<TransferDetails, Error>> {\n        try {\n            const connection = new Connection(this.rpcUrl, \"confirmed\");\n\n            const transaction = await connection.getParsedTransaction(tx, {\n                maxSupportedTransactionVersion: 0,\n            });\n\n            if (!transaction || transaction.meta?.err) {\n                return Result.err(new TransactionNotFoundError());\n            }\n\n            const instructions = transaction.transaction.message.instructions;\n\n            const transferInstruction = instructions.find((instruction) => {\n                if (\"parsed\" in instruction) {\n                    return instruction.parsed.type === \"transfer\" || instruction.parsed.type === \"transferChecked\";\n                }\n                return false;\n            });\n\n            if (transferInstruction && \"parsed\" in transferInstruction) {\n                const { info, type } = transferInstruction.parsed;\n                if (\"destination\" in info && \"source\" in info) {\n                    if (type === \"transferChecked\" && \"tokenAmount\" in info) {\n                        return Result.ok({\n                            receiver: info.destination,\n                            sender: info.source,\n                            amount: info.tokenAmount.uiAmount,\n                        });\n                    } else if (type === \"transfer\" && \"amount\" in info) {\n                        return Result.ok({\n                            receiver: info.destination,\n                            sender: info.source,\n                            amount: info.amount,\n                        });\n                    }\n                }\n            }\n\n            return Result.err(new TransferInstructionNotFoundError());\n        } catch (error) {\n            return Result.err(error instanceof Error ? error : new Error(String(error)));\n        }\n    }\n\n    async verifyEligiblePayment(params: {\n        paymentHash: string;\n        totalCost: number;\n        walletAddress: string;\n    }): Promise<Result<void, Error>> {\n        const { paymentHash, totalCost, walletAddress } = params;\n\n        const slippage = 0.005;\n        const totalCostWithSlippage = totalCost * (1 + slippage);\n    \n        const isInUse = await this.paymentsStorage.getPayment(paymentHash);\n    \n        if (isInUse) {\n            return Result.err(new Error(\"Payment already in use\"));\n        }\n    \n        // First try SOL transfer\n        const solResult = await this.getSolTransferDetails(paymentHash);\n    \n        if (solResult.isOk) {\n            const { receiver, sender, amount } = solResult.unwrap();\n    \n            if (sender !== walletAddress || receiver !== this.walletPublicKey) {\n                return Result.err(new Error(\"Invalid sender or receiver addresses for SOL transfer\"));\n            }\n\n            // get AITHRA price in SOL\n            const priceResult = await this.getAithraPriceInSol();\n            \n            if (priceResult.isErr()) {\n                return Result.err(priceResult.getErr());\n            }\n\n            const aithraPriceInSol = priceResult.unwrap();\n\n            const totalCostInSol = Number(totalCostWithSlippage) * Number(aithraPriceInSol);\n\n    \n            if (Number(amount) <= Number(totalCostInSol)) {\n                return Result.err(new Error(\"Insufficient SOL funds\"));\n            }\n    \n            await this.paymentsStorage.setPayment({\n                hash: paymentHash,\n                amount: Number(amount),\n                date: new Date().toISOString(),\n                from: sender,\n                to: receiver\n            });\n    \n            return Result.ok();\n        }\n    \n        // If not SOL transfer, try SPL token transfer\n        const splResult = await this.getSplTransferDetails(paymentHash);\n    \n        if (splResult.isOk) {\n            const { receiver, sender, amount } = splResult.unwrap();\n    \n            const sourceAta = getAssociatedTokenAddressSync(this.AITHRA_MINT, new PublicKey(walletAddress), true);\n            const receiverAta = getAssociatedTokenAddressSync(this.AITHRA_MINT, new PublicKey(this.walletPublicKey), true);\n    \n            if (sender !== sourceAta.toBase58() || receiver !== receiverAta.toBase58()) {\n                return Result.err(new Error(\"Invalid sender or receiver addresses for SPL transfer\"));\n            }\n    \n            if (Number(amount) <= Number(totalCostWithSlippage)) {\n                return Result.err(new Error(\"Insufficient token funds\"));\n            }\n    \n            await this.paymentsStorage.setPayment({\n                hash: paymentHash,\n                amount: Number(amount),\n                date: new Date().toISOString(),\n                from: sender,\n                to: receiver\n            });\n    \n            return Result.ok();\n        }\n    \n        return Result.err(new Error(\"No valid transfer found in transaction\"));\n    }\n\n    public async deletePayment(paymentHash: string): Promise<Result<void,Error>> {\n        try {\n            await this.paymentsStorage.deletePayment(paymentHash);\n            return Result.ok();\n        } catch (error) {\n            return Result.err(error instanceof Error ? error : new Error(String(error)));\n        }\n    }\n\n    private async getAithraPriceInSol(): Promise<Result<number, Error>> {\n        try {\n          const tokenData = await (\n            await fetch(\n              `https://api.jup.ag/price/v2?ids=${this.AITHRA_MINT.toString()}&vsToken=So11111111111111111111111111111111111111112`\n            )\n          ).json();\n          return Result.ok(tokenData.data[this.AITHRA_MINT.toString()].price);\n        } catch (err) {\n          return Result.err(new Error(`Failed to get SOL price: ${err.message}`));\n        }\n      }\n}","import { IAgentRuntime } from \"@elizaos/core\";\nimport { EventEmitter } from \"events\";\n\n\nexport interface Payment { \n    hash:string,\n    amount:number,\n    date: string,\n    from: string,\n    to: string,\n}\n\nexport class CacheStorage<T> {\n    private runtime: IAgentRuntime;\n    private cacheKey: string;\n    private compareFunction: (a: T, b: T) => boolean;\n\n    constructor(\n        runtime: IAgentRuntime,\n        cacheKey: string,\n        compareFunction: (a: T, b: T) => boolean = (a, b) => a === b\n    ) {\n        this.runtime = runtime;\n        this.cacheKey = cacheKey;\n        this.compareFunction = compareFunction;\n    }\n\n    async setValue(key: string, value: T): Promise<void> {\n        if (!value) {\n            console.warn(\"Value is undefined, skipping set\");\n            return;\n        }\n        await this.runtime.cacheManager.set(key, value);\n    }\n\n    async getValue<R>(key: string): Promise<R | null> {\n        return await this.runtime.cacheManager.get<R>(key);\n    }\n\n    async append(value: T | T[]): Promise<void> {\n        if (!value) {\n            console.warn(\"Value is undefined, skipping append\");\n            return;\n        }\n\n        const cached = await this.getAll();\n        const valuesToAdd = Array.isArray(value) ? value : [value];\n\n        valuesToAdd.forEach((item) => {\n            if (\n                !cached.some((existingItem) =>\n                    this.compareFunction(existingItem, item)\n                )\n            ) {\n                cached.push(item);\n            }\n        });\n\n        await this.runtime.cacheManager.set(this.cacheKey, cached);\n    }\n\n    async remove(value: T): Promise<void> {\n        if (!value) {\n            console.warn(\"Value is undefined, skipping removal\");\n            return;\n        } \n\n        const cached = await this.getAll();\n        const filtered = cached.filter(\n            (item) => !this.compareFunction(item, value)\n        );\n        await this.runtime.cacheManager.set(this.cacheKey, filtered);\n    }\n\n    async getAll(): Promise<T[]> {\n        const cached = await this.runtime.cacheManager.get<T[]>(this.cacheKey);\n        return cached || [];\n    }\n\n    async clear(): Promise<void> {\n        await this.runtime.cacheManager.set(this.cacheKey, []);\n    }\n}\n\nexport class PaymentsStorage {\n    runtime: IAgentRuntime;\n    private storage: CacheStorage<Payment>;\n    private hashesStorage: CacheStorage<string>;\n    private readonly PAYMENT_PREFIX = \"payments/payment/\";\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n        this.storage = new CacheStorage<Payment>(runtime, \"payments\");\n        this.hashesStorage = new CacheStorage<string>(runtime, \"paymentHashes\");\n    }\n\n\n    async checkPaymentExists(hash: string): Promise<boolean> {\n        const key = this.PAYMENT_PREFIX + hash;\n        return await this.storage.getValue(key) !== null;\n    }\n\n    async setPayment(payment: Payment): Promise<void> {\n        const key = this.PAYMENT_PREFIX + payment.hash;\n        await this.storage.setValue(key, payment);\n        await this.hashesStorage.append(payment.hash);\n      \n    }\n\n    async getPayment(hash: string): Promise<Payment | null> {\n        const key = this.PAYMENT_PREFIX + hash;\n        return await this.storage.getValue<Payment | null>(key);\n    }\n\n    async deletePayment(hash:string):Promise<void>{\n        const key = this.PAYMENT_PREFIX + hash;\n        await this.storage.remove(key);\n        await this.hashesStorage.remove(hash);\n    }\n\n}","import { Plugin } from \"@elizaos/core\";\nimport { AithraService } from \"../services/aithraService\";\nimport createMusicPlaylist from \"../actions/createMusicPlaylist\";\n\nexport const aithraToolkitPlugin: Plugin = {\n    name: \"aithra-toolkit\",\n    description:\n        \"A simple toolkit enabling agents to tokenize any data with a few lines of code\",\n    actions: [createMusicPlaylist],\n    providers: [],\n    evaluators: [],\n    services: [new AithraService()],\n    clients: [],\n};\n","import { aithraToolkitPlugin } from \"./plugins/aithraToolkitPlugin\";\n\nexport * from \"./plugins/aithraToolkitPlugin\";\nexport * from \"./services/aithraService\";\nexport * from  \"@aithranetwork/sdk-aithra-toolkit\";\n\nexport default aithraToolkitPlugin;\n"],"mappings":";;;;AAAA,SAEIA,eAEG;AACP,SAASC,YAAYC,eAAe;AACpC,SAASC,qBAAqD;AAC9D,OAAOC,UAAU;AACjB,YAAYC,QAAQ;AACpB,YAAYC,QAAQ;AACpB,YAAYC,UAAU;AAEf,IAAMC,gBAAN,cAA4BC,QAAAA;EAZnC,OAYmCA;;;EACvBC;EACAC;EACAC;EACAC;EACAC,QAAQ;EAEhBC,cAAc;AACV,UAAK;EACT;EAEAC,cAAsB;AAClB,WAAO,KAAKH;EAChB;EAEQI,8BAAoC;AACxC,UAAMC,aAAkBC,UAAK,KAAKN,UAAU,QAAA;AAC5CO,IAAGC,UAAOH,YAAY;MAAEI,WAAW;MAAMC,OAAO;IAAK,CAAA;AACrDH,IAAGI,aAAUN,YAAY;MAAEI,WAAW;IAAK,CAAA;AAC3C,eAAWG,UAAU;MAAC;MAAS;OAAW;AACtCL,MAAGI,aAAeL,UAAKD,YAAYO,MAAAA,GAAS;QAAEH,WAAW;MAAK,CAAA;IAClE;EACJ;EAEQI,gBAA2B;AAC/B,UAAMC,WAAgBR,UAAK,KAAKN,UAAU,UAAU,WAAA;AACpD,QAAI,CAAIe,cAAWD,QAAAA,EAAW,QAAO,CAAA;AACrC,UAAME,eAAkBC,gBAAaH,UAAU,MAAA;AAC/C,WAAOI,KAAKC,MAAMH,YAAAA;EACtB;EAEQI,eAAeC,WAA4B;AAC/C,UAAMP,WAAgBR,UAAK,KAAKN,UAAU,UAAU,WAAA;AACpDO,IAAGe,iBAAcR,UAAUI,KAAKK,UAAUF,WAAW,MAAM,CAAA,CAAA;EAC/D;EAEQG,4BAAkC;AACtC,QAAI;AACA,WAAKpB,4BAA2B;IACpC,SAASqB,KAAK;AACVC,cAAQC,MAAM,6CAA6CF,GAAAA;IAC/D;EACJ;EAEA,WAAWG,cAAc;AACrB,WAAO;EACX;EAGA,MAAMC,aAAaC,eAAsBC,eAAuC;AAC5E,UAAMC,WAAY,MAAM,KAAKnC,QAAQgC,aAAaC,eAAeC,aAAAA;AAElE,QAAIC,SAASC,KAAI,GAAG;AACb,aAAOD,SAASE,OAAM;IAC7B;EAGH;EAEA,MAAMC,WAAWC,SAAwBpC,UAAkC;AACvE,SAAKF,aAAa,IAAIuC,WAClBD,QAAQE,WAAW,gBAAA,KACf,uCACJ,WAAA;AAGJ,UAAMC,aAAaH,QAAQE,WAAW,oBAAA;AACtC,QAAI,CAACC,YAAY;AACb,YAAM,IAAIC,MACN,qDAAA;IAER;AAEA,SAAKzC,UAAU0C,QAAQC,cAAcC,KAAKC,OAAOL,UAAAA,CAAAA;AAGjD,SAAK1C,UAAU,IAAIgD,cAAc;MAC7B/C,YAAY,KAAKA;MACjBC,SAAS,KAAKA;MACd+C,aACIC,OAAOX,QAAQE,WAAW,qBAAA,CAAA,KAC1BS,OAAOC,QAAQC,IAAIC,mBAAmB,KACtC;IACR,CAAA;AAEA,SAAKlD,WAAgBmD,aACjBnD,YAAiBM,UAAQ8C,UAAM,GAAI,aAAA,CAAA;AAGvC,SAAK5B,0BAAyB;EAClC;EAEA,MAAM6B,yBAAyBC,QAkBA;AAC3B,QAAI;AACA,YAAMC,SAAS,MAAM,KAAK1D,QAAQwD,yBAAyB;QACvDG,YAAiBlD,UAAK,KAAKN,UAAU,QAAA;QACrC,GAAGsD;MACP,CAAA;AAEA/C,MAAGC,UAAYF,UAAK,KAAKN,UAAU,QAAA,GAAW;QAC1CS,WAAW;QACXC,OAAO;MACX,CAAA;AAEA,UAAI6C,OAAOtB,KAAI,GAAG;AACd,eAAOsB,OAAOrB,OAAM;MACxB;IACJ,SAASP,OAAO;AACZD,cAAQC,MAAM,gCAAgCA,KAAAA;AAC9C,YAAMA;IACV;EACJ;EAEQ8B,kBACJC,QACAC,WACAC,UACM;AACN,UAAMC,WAAgBvD,UAClB,KAAKN,UACL,UACA2D,WACAC,QAAAA;AAEJrD,IAAGe,iBAAcuC,UAAUH,MAAAA;AAC3B,WAAOG;EACX;EAEQC,cACJC,WACAC,eAMAC,aACI;AACJ,SAAKR,kBAAkBM,WAAW,SAAS,QAAQE,WAAAA,MAAiB;AACpE,QAAI5C,YAAY,KAAKR,cAAa;AAClCQ,cAAU6C,KAAK;MACX,CAAC,QAAQD,WAAAA,EAAa,GAAG;QAAEE,UAAUH;MAAc;IACvD,CAAA;AACA,SAAK5C,eAAeC,SAAAA;EACxB;EAEA+C,mBAAmBd,QAYV;AACL,SAAKrD,SAAS;AACd,SAAK6D,cACDR,OAAOe,MAAMC,MACbhB,OAAOe,MAAMF,UACb,KAAKlE,KAAK;AAGd,QAAIqD,OAAOe,MAAME,OAAO;AACpB,WAAKd,kBACDH,OAAOe,MAAME,OACb,UACA,QAAQ,KAAKtE,KAAK,UAAUqD,OAAOe,MAAMG,kBAAkB,KAAA,EAAO;IAE1E;EACJ;EAEAC,oBAAoBnB,QAWX;AACL,aAASoB,IAAI,GAAGA,IAAIpB,OAAOqB,OAAOC,QAAQF,KAAK;AAC3C,WAAKN,mBAAmB;QACpBC,OAAOf,OAAOqB,OAAOD,CAAAA;MACzB,CAAA;IACJ;EACJ;EAEAG,uBAAuBvB,QAGZ;AACP,WAAO,KAAKG,kBACRH,OAAOwB,WACP,IACA,aAAaxB,OAAOyB,aAAa,KAAA,EAAO;EAEhD;AACJ;;;AC1OA,SAASC,gBAAyBC,eAA+BC,0BAAyEC,kBAAsC;;;ACAhL,OAAO;AACP,OAAOC,eAAe;AACtB,SAAQC,cAAa;AAGd,IAAMC,cAAN,MAAMA;EALb,OAKaA;;;;;EACTC,YACWC,MACAC,aACT;SAFSD,OAAAA;SACAC,cAAAA;EACR;AACP;AAEO,SAASC,YAAYD,aAAmB;AAC3C,SAAO,SAASE,QAAaC,aAAmB;AAC5CC,YAAQC,eAAe,eAAeL,aAAaE,QAAQC,WAAAA;EAC/D;AACJ;AAJgBF;AAMT,IAAMK,kBAAN,MAAMA;EAlBb,OAkBaA;;;EACT,OAAOC,mBAAmBC,WAAwB;AAC9C,UAAMC,SAAS,KAAKC,WAAWF,SAAAA;AAC/B,WAAO,KAAKG,gBAAgBF,MAAAA;EAChC;EAEA,OAAeC,WAAWF,WAA6C;AACnE,UAAMC,SAAsC,CAAC;AAC7C,UAAMG,WAAW,IAAIJ,UAAAA;AACrB,UAAMK,YAAYC,OAAOC,eAAeH,QAAAA;AAExC,eAAWI,OAAOF,OAAOG,KAAKL,QAAAA,GAAW;AACrC,YAAMb,OAAOK,QAAQc,YAAY,eAAeL,WAAWG,GAAAA;AAC3D,YAAMhB,cAAcI,QAAQc,YAAY,eAAeN,UAAUI,GAAAA;AACjE,YAAMG,cAAcP,SAASI,GAAAA;AAE7B,UAAII;AACJ,UAAIrB,SAASsB,SAASA,MAAMC,QAAQH,WAAAA,GAAc;AAC9CC,qBAAa;MACjB,WAAW,KAAKG,eAAeJ,WAAAA,GAAc;AACzCC,qBAAa,KAAKI,kBAAkBL,WAAAA;MACxC,OAAO;AACHC,qBAAa,KAAKK,cAAc1B,QAAQoB,aAAarB,aAAaqB,WAAAA;MACtE;AAEAV,aAAOO,GAAAA,IAAO,IAAInB,YAAYuB,YAAYpB,WAAAA;IAC9C;AAEA,WAAOS;EACX;EAEA,OAAec,eAAeG,OAAqB;AAC/C,WAAOA,UAAU,QACV,OAAOA,UAAU,YACjB,CAACL,MAAMC,QAAQI,KAAAA,KACfZ,OAAOG,KAAKS,KAAAA,EAAOC,SAAS;EACvC;EAEA,OAAeH,kBAAkBI,KAAkB;AAC/C,QAAIC,SAAS;AACb,eAAW,CAACb,KAAKU,KAAAA,KAAUZ,OAAOgB,QAAQF,GAAAA,GAAM;AAC5C,YAAM7B,OAAO,OAAO2B;AACpBG,gBAAU,WAAWb,GAAAA,KAAQjB,IAAAA;;IACjC;AACA8B,cAAU;AACV,WAAOA;EACX;EAEA,OAAeJ,cAAc1B,MAAW2B,OAAoB;AACxD,QAAI,CAAC3B,KAAM,QAAO,OAAO2B;AAEzB,UAAMK,WAAWhC,KAAKiC,KAAKC,YAAW;AACtC,YAAQF,UAAAA;MACJ,KAAK;AAAU,eAAO;MACtB,KAAK;AAAU,eAAO;MACtB,KAAK;AAAW,eAAO;MACvB,KAAK;AAAS,eAAO;MACrB,KAAK;AAAU,eAAO,OAAOL;MAC7B;AAAS,eAAO3B,KAAKiC;IACzB;EACJ;EAEA,OAAerB,gBAAgBF,QAA6C;AACxE,QAAIyB,SAAS;AAEbpB,WAAOgB,QAAQrB,MAAAA,EAAQ0B,QAAQ,CAAC,CAACnB,KAAKoB,KAAAA,MAAM;AACxC,UAAIA,MAAMpC,aAAa;AACnBkC,kBAAU,QAAQE,MAAMpC,WAAW;;MACvC;AACA,YAAMqC,SAASD,MAAMrC,KAAKuC,SAAS,KAAA,IAAS,KAAK;AACjDJ,gBAAU,KAAKlB,GAAAA,KAAQoB,MAAMrC,IAAI;;IACrC,CAAA;AAEAmC,cAAU;AACV,WAAOA;EACX;AACJ;AAcO,SAASK,sBAAsBC,cAAoB;AAEtD,QAAMC,aAAaD,aAAaE,QAAQ,4BAA4B,EAAA;AAGpE,QAAMC,YAAYH,aAAaI,MAAM,GAAA,EAAK,CAAA,GAAIA,MAAM,GAAA,EAAK,CAAA,KAAM;AAG/D,QAAMC,SAASC,OAAOC,KAAKN,YAAY,QAAA;AAEvC,SAAO;IACLI;IACAF;EACF;AACF;AAdcJ;AAgBhB,eAAsBS,cAAc,EAChCd,QACAe,QACAC,kBAAiB,GAKlBC,SAAsB;AACrB,MAAI;AACA,UAAMC,YAAY,IAAIC,UAAU;MAC5BC,MAAMH,QAAQI,WAAW,qBAAA;IAC7B,CAAA;AAEA,UAAMC,QAAQ;MACVP,QAAQA,UAAU;MAClBQ,SAAS;MACTC,WAAWR,qBAAqB;MAChCS,aAAa;IACjB;AAEA,UAAMC,WAAW,MAAMR,UAAUS,IAAI,oBAAoB;MAAEL;IAAM,CAAA;AAGjE,QAAII,oBAAoBE,gBAAgB;AACpC,YAAMC,SAASH,SAASI,UAAS;AACjC,YAAMC,SAAuB,CAAA;AAE7B,aAAO,MAAM;AACT,cAAM,EAAEC,MAAMxC,MAAK,IAAK,MAAMqC,OAAOI,KAAI;AACzC,YAAID,KAAM;AACVD,eAAOG,KAAK1C,KAAAA;MAChB;AAEA,YAAM2C,cAAcvB,OAAOwB,OAAOL,OAAOM,IAAIC,CAAAA,UAAS1B,OAAOC,KAAKyB,KAAAA,CAAAA,CAAAA;AAClE,aAAOC,OAAOC,GAAGL,WAAAA;IACrB;AAGA,WAAOI,OAAOE,IAAI,IAAIC,MAAM,4CAAA,CAAA;EAChC,SAASC,OAAO;AACZ,WAAOJ,OAAOE,IAAIE,iBAAiBD,QAAQC,QAAQ,IAAID,MAAM,+CAAA,CAAA;EACjE;AACJ;AA3CsB5B;;;AD1HtB,SAAQ8B,2BAA2B;;;AEDnC,SAASC,SAAS;AAEX,IAAMC,kBAAkBC,EAAEC,OAAO;EACpCC,gBAAgBF,EAAEG,OAAM,EAAGC,IAAI,GAAG,4BAAA;EAClCC,oBAAoBL,EAAEG,OAAM,EAAGC,IAAI,GAAG,gCAAA;EACtCE,qBAAqBN,EAChBO,OAAM,EACNH,IAAI,GAAG,4CAAA;AAChB,CAAA;AAIA,eAAsBI,qBAClBC,SAAsB;AAEtB,MAAI;AACA,UAAMC,SAAS;MACXR,gBACIO,QAAQE,WAAW,gBAAA,KACnBC,QAAQC,IAAIX;MAChBG,oBACII,QAAQE,WAAW,oBAAA,KACnBC,QAAQC,IAAIR;MAChBC,qBACIQ,OAAOL,QAAQE,WAAW,qBAAA,CAAA,KAC1BG,OAAOF,QAAQC,IAAIP,mBAAmB;IAC9C;AAEA,WAAOP,gBAAgBgB,MAAML,MAAAA;EACjC,SAASM,OAAO;AACZ,QAAIA,iBAAiBhB,EAAEiB,UAAU;AAC7B,YAAMC,gBAAgBF,MAAMG,OACvBC,IAAI,CAACC,QAAQ,GAAGA,IAAIC,KAAKC,KAAK,GAAA,CAAA,KAASF,IAAIG,OAAO,EAAE,EACpDD,KAAK,IAAA;AACV,YAAM,IAAIE,MACN;EAA4CP,aAAAA,EAAe;IAEnE;AACA,UAAMF;EACV;AACJ;AA5BsBR;;;ACbtB,SAASkB,cAAAA,aAAYC,WAAUC,WAAAA,gBAAe;AAC9C,SAASC,qCAAqC;;;ACWvC,IAAMC,eAAN,MAAMA;EAAb,OAAaA;;;EACDC;EACAC;EACAC;EAERC,YACIH,SACAC,UACAC,kBAA2C,CAACE,GAAGC,MAAMD,MAAMC,GAC7D;AACE,SAAKL,UAAUA;AACf,SAAKC,WAAWA;AAChB,SAAKC,kBAAkBA;EAC3B;EAEA,MAAMI,SAASC,KAAaC,OAAyB;AACjD,QAAI,CAACA,OAAO;AACRC,cAAQC,KAAK,kCAAA;AACb;IACJ;AACA,UAAM,KAAKV,QAAQW,aAAaC,IAAIL,KAAKC,KAAAA;EAC7C;EAEA,MAAMK,SAAYN,KAAgC;AAC9C,WAAO,MAAM,KAAKP,QAAQW,aAAaG,IAAOP,GAAAA;EAClD;EAEA,MAAMQ,OAAOP,OAA+B;AACxC,QAAI,CAACA,OAAO;AACRC,cAAQC,KAAK,qCAAA;AACb;IACJ;AAEA,UAAMM,SAAS,MAAM,KAAKC,OAAM;AAChC,UAAMC,cAAcC,MAAMC,QAAQZ,KAAAA,IAASA,QAAQ;MAACA;;AAEpDU,gBAAYG,QAAQ,CAACC,SAAAA;AACjB,UACI,CAACN,OAAOO,KAAK,CAACC,iBACV,KAAKtB,gBAAgBsB,cAAcF,IAAAA,CAAAA,GAEzC;AACEN,eAAOS,KAAKH,IAAAA;MAChB;IACJ,CAAA;AAEA,UAAM,KAAKtB,QAAQW,aAAaC,IAAI,KAAKX,UAAUe,MAAAA;EACvD;EAEA,MAAMU,OAAOlB,OAAyB;AAClC,QAAI,CAACA,OAAO;AACRC,cAAQC,KAAK,sCAAA;AACb;IACJ;AAEA,UAAMM,SAAS,MAAM,KAAKC,OAAM;AAChC,UAAMU,WAAWX,OAAOY,OACpB,CAACN,SAAS,CAAC,KAAKpB,gBAAgBoB,MAAMd,KAAAA,CAAAA;AAE1C,UAAM,KAAKR,QAAQW,aAAaC,IAAI,KAAKX,UAAU0B,QAAAA;EACvD;EAEA,MAAMV,SAAuB;AACzB,UAAMD,SAAS,MAAM,KAAKhB,QAAQW,aAAaG,IAAS,KAAKb,QAAQ;AACrE,WAAOe,UAAU,CAAA;EACrB;EAEA,MAAMa,QAAuB;AACzB,UAAM,KAAK7B,QAAQW,aAAaC,IAAI,KAAKX,UAAU,CAAA,CAAE;EACzD;AACJ;AAEO,IAAM6B,kBAAN,MAAMA;EAxEb,OAwEaA;;;EACT9B;EACQ+B;EACAC;EACSC,iBAAiB;EAElC9B,YAAYH,SAAwB;AAChC,SAAKA,UAAUA;AACf,SAAK+B,UAAU,IAAIhC,aAAsBC,SAAS,UAAA;AAClD,SAAKgC,gBAAgB,IAAIjC,aAAqBC,SAAS,eAAA;EAC3D;EAGA,MAAMkC,mBAAmBC,MAAgC;AACrD,UAAM5B,MAAM,KAAK0B,iBAAiBE;AAClC,WAAO,MAAM,KAAKJ,QAAQlB,SAASN,GAAAA,MAAS;EAChD;EAEA,MAAM6B,WAAWC,SAAiC;AAC9C,UAAM9B,MAAM,KAAK0B,iBAAiBI,QAAQF;AAC1C,UAAM,KAAKJ,QAAQzB,SAASC,KAAK8B,OAAAA;AACjC,UAAM,KAAKL,cAAcjB,OAAOsB,QAAQF,IAAI;EAEhD;EAEA,MAAMG,WAAWH,MAAuC;AACpD,UAAM5B,MAAM,KAAK0B,iBAAiBE;AAClC,WAAO,MAAM,KAAKJ,QAAQlB,SAAyBN,GAAAA;EACvD;EAEA,MAAMgC,cAAcJ,MAA0B;AAC1C,UAAM5B,MAAM,KAAK0B,iBAAiBE;AAClC,UAAM,KAAKJ,QAAQL,OAAOnB,GAAAA;AAC1B,UAAM,KAAKyB,cAAcN,OAAOS,IAAAA;EACpC;AAEJ;;;ADpHA,SAASK,UAAAA,eAAc;AACvB,OAAOC,WAAU;AAEjB,IAAMC,2BAAN,MAAMA,kCAAiCC,MAAAA;EAPvC,OAOuCA;;;EACnCC,cAAc;AACV,UAAM,uBAAA;EACV;AACJ;AAEA,IAAMC,mCAAN,MAAMA,0CAAyCF,MAAAA;EAb/C,OAa+CA;;;EAC3CC,cAAc;AACV,UAAM,+CAAA;EACV;AACJ;AAQO,IAAME,kBAAN,MAAMA;EAzBb,OAyBaA;;;EACQC;EACAC;EACAC,cAAc,IAAIC,UAC/B,6CAAA;EAEaC,kBAAyB;EAE1CP,YAAYG,QAAeK,SAAuB;AAC9C,SAAKL,SAASA;AACd,SAAKC,kBAAkB,IAAIK,gBAAgBD,OAAAA;AAE3C,UAAME,aAAaF,QAAQG,WAAW,oBAAA;AACtC,UAAMC,UAAUC,SAAQC,cAAcC,MAAKC,OAAON,UAAAA,CAAAA;AAElD,SAAKH,kBAAkBK,QAAQK,UAAUC,SAAQ;EAGrD;EAGA,MAAcC,sBAAsBC,IAAqD;AACrF,QAAI;AACA,YAAMC,aAAa,IAAIC,YAAW,KAAKnB,QAAQ,WAAA;AAE/C,YAAMoB,cAAc,MAAMF,WAAWG,qBAAqBJ,IAAI;QAC1DK,gCAAgC;MACpC,CAAA;AAEA,UAAI,CAACF,eAAeA,YAAYG,MAAMC,KAAK;AACvC,eAAOC,QAAOD,IAAI,IAAI7B,yBAAAA,CAAAA;MAC1B;AAEA,YAAM+B,eAAeN,YAAYA,YAAYO,QAAQD;AAErD,YAAME,sBAAsBF,aAAaG,KAAK,CAACC,gBAAAA;AAC3C,YAAI,YAAYA,aAAa;AACzB,iBAAOA,YAAYC,YAAY,YAAYD,YAAYE,OAAOC,SAAS;QAC3E;AACA,eAAO;MACX,CAAA;AAEA,UAAIL,uBAAuB,YAAYA,qBAAqB;AACxD,cAAM,EAAEM,KAAI,IAAKN,oBAAoBI;AACrC,YAAI,iBAAiBE,QAAQ,YAAYA,MAAM;AAC3C,iBAAOT,QAAOU,GAAG;YACbC,UAAUF,KAAKG;YACfC,QAAQJ,KAAKK;YACbC,SAASC,OAAOP,KAAKQ,QAAQ,IAAI,KAAKC,SAAQ;UAClD,CAAA;QACJ;MACJ;AAEA,aAAOlB,QAAOD,IAAI,IAAI1B,iCAAAA,CAAAA;IAC1B,SAAS8C,OAAO;AACZ,aAAOnB,QAAOD,IAAIoB,iBAAiBhD,QAAQgD,QAAQ,IAAIhD,MAAMiD,OAAOD,KAAAA,CAAAA,CAAAA;IACxE;EACJ;EAGA,MAAcE,sBAAsB7B,IAAqD;AACrF,QAAI;AACA,YAAMC,aAAa,IAAIC,YAAW,KAAKnB,QAAQ,WAAA;AAE/C,YAAMoB,cAAc,MAAMF,WAAWG,qBAAqBJ,IAAI;QAC1DK,gCAAgC;MACpC,CAAA;AAEA,UAAI,CAACF,eAAeA,YAAYG,MAAMC,KAAK;AACvC,eAAOC,QAAOD,IAAI,IAAI7B,yBAAAA,CAAAA;MAC1B;AAEA,YAAM+B,eAAeN,YAAYA,YAAYO,QAAQD;AAErD,YAAME,sBAAsBF,aAAaG,KAAK,CAACC,gBAAAA;AAC3C,YAAI,YAAYA,aAAa;AACzB,iBAAOA,YAAYE,OAAOC,SAAS,cAAcH,YAAYE,OAAOC,SAAS;QACjF;AACA,eAAO;MACX,CAAA;AAEA,UAAIL,uBAAuB,YAAYA,qBAAqB;AACxD,cAAM,EAAEM,MAAMD,KAAI,IAAKL,oBAAoBI;AAC3C,YAAI,iBAAiBE,QAAQ,YAAYA,MAAM;AAC3C,cAAID,SAAS,qBAAqB,iBAAiBC,MAAM;AACrD,mBAAOT,QAAOU,GAAG;cACbC,UAAUF,KAAKG;cACfC,QAAQJ,KAAKK;cACbC,QAAQN,KAAKa,YAAYC;YAC7B,CAAA;UACJ,WAAWf,SAAS,cAAc,YAAYC,MAAM;AAChD,mBAAOT,QAAOU,GAAG;cACbC,UAAUF,KAAKG;cACfC,QAAQJ,KAAKK;cACbC,QAAQN,KAAKM;YACjB,CAAA;UACJ;QACJ;MACJ;AAEA,aAAOf,QAAOD,IAAI,IAAI1B,iCAAAA,CAAAA;IAC1B,SAAS8C,OAAO;AACZ,aAAOnB,QAAOD,IAAIoB,iBAAiBhD,QAAQgD,QAAQ,IAAIhD,MAAMiD,OAAOD,KAAAA,CAAAA,CAAAA;IACxE;EACJ;EAEA,MAAMK,sBAAsBC,QAIK;AAC7B,UAAM,EAAEC,aAAaC,WAAWC,cAAa,IAAKH;AAElD,UAAMI,WAAW;AACjB,UAAMC,wBAAwBH,aAAa,IAAIE;AAE/C,UAAME,UAAU,MAAM,KAAKvD,gBAAgBwD,WAAWN,WAAAA;AAEtD,QAAIK,SAAS;AACT,aAAO/B,QAAOD,IAAI,IAAI5B,MAAM,wBAAA,CAAA;IAChC;AAGA,UAAM8D,YAAY,MAAM,KAAK1C,sBAAsBmC,WAAAA;AAEnD,QAAIO,UAAUC,MAAM;AAChB,YAAM,EAAEvB,UAAUE,QAAQE,OAAM,IAAKkB,UAAUE,OAAM;AAErD,UAAItB,WAAWe,iBAAiBjB,aAAa,KAAKhC,iBAAiB;AAC/D,eAAOqB,QAAOD,IAAI,IAAI5B,MAAM,uDAAA,CAAA;MAChC;AAGA,YAAMiE,cAAc,MAAM,KAAKC,oBAAmB;AAElD,UAAID,YAAYE,MAAK,GAAI;AACrB,eAAOtC,QAAOD,IAAIqC,YAAYG,OAAM,CAAA;MACxC;AAEA,YAAMC,mBAAmBJ,YAAYD,OAAM;AAE3C,YAAMM,iBAAiBzB,OAAOc,qBAAAA,IAAyBd,OAAOwB,gBAAAA;AAG9D,UAAIxB,OAAOD,MAAAA,KAAWC,OAAOyB,cAAAA,GAAiB;AAC1C,eAAOzC,QAAOD,IAAI,IAAI5B,MAAM,wBAAA,CAAA;MAChC;AAEA,YAAM,KAAKK,gBAAgBkE,WAAW;QAClCC,MAAMjB;QACNX,QAAQC,OAAOD,MAAAA;QACf6B,OAAM,oBAAIC,KAAAA,GAAOC,YAAW;QAC5BC,MAAMlC;QACNmC,IAAIrC;MACR,CAAA;AAEA,aAAOX,QAAOU,GAAE;IACpB;AAGA,UAAMuC,YAAY,MAAM,KAAK5B,sBAAsBK,WAAAA;AAEnD,QAAIuB,UAAUf,MAAM;AAChB,YAAM,EAAEvB,UAAUE,QAAQE,OAAM,IAAKkC,UAAUd,OAAM;AAErD,YAAMe,YAAYC,8BAA8B,KAAK1E,aAAa,IAAIC,UAAUkD,aAAAA,GAAgB,IAAA;AAChG,YAAMwB,cAAcD,8BAA8B,KAAK1E,aAAa,IAAIC,UAAU,KAAKC,eAAe,GAAG,IAAA;AAEzG,UAAIkC,WAAWqC,UAAU5D,SAAQ,KAAMqB,aAAayC,YAAY9D,SAAQ,GAAI;AACxE,eAAOU,QAAOD,IAAI,IAAI5B,MAAM,uDAAA,CAAA;MAChC;AAEA,UAAI6C,OAAOD,MAAAA,KAAWC,OAAOc,qBAAAA,GAAwB;AACjD,eAAO9B,QAAOD,IAAI,IAAI5B,MAAM,0BAAA,CAAA;MAChC;AAEA,YAAM,KAAKK,gBAAgBkE,WAAW;QAClCC,MAAMjB;QACNX,QAAQC,OAAOD,MAAAA;QACf6B,OAAM,oBAAIC,KAAAA,GAAOC,YAAW;QAC5BC,MAAMlC;QACNmC,IAAIrC;MACR,CAAA;AAEA,aAAOX,QAAOU,GAAE;IACpB;AAEA,WAAOV,QAAOD,IAAI,IAAI5B,MAAM,wCAAA,CAAA;EAChC;EAEA,MAAakF,cAAc3B,aAAkD;AACzE,QAAI;AACA,YAAM,KAAKlD,gBAAgB6E,cAAc3B,WAAAA;AACzC,aAAO1B,QAAOU,GAAE;IACpB,SAASS,OAAO;AACZ,aAAOnB,QAAOD,IAAIoB,iBAAiBhD,QAAQgD,QAAQ,IAAIhD,MAAMiD,OAAOD,KAAAA,CAAAA,CAAAA;IACxE;EACJ;EAEA,MAAckB,sBAAsD;AAChE,QAAI;AACF,YAAMiB,YAAY,OAChB,MAAMC,MACJ,mCAAmC,KAAK9E,YAAYyC,SAAQ,CAAA,sDAAwD,GAEtHsC,KAAI;AACN,aAAOxD,QAAOU,GAAG4C,UAAUG,KAAK,KAAKhF,YAAYyC,SAAQ,CAAA,EAAIwC,KAAK;IACpE,SAAS3D,KAAK;AACZ,aAAOC,QAAOD,IAAI,IAAI5B,MAAM,4BAA4B4B,IAAIG,OAAO,EAAE,CAAA;IACvE;EACF;AACN;;;;;;;;;;;;;;AHhOO,IAAMyD,uBAAN,MAAMA;SAAAA;;;EAETC;EAGAC;EAGAC;EAGAC;EAGAC;EAGAC,gBAAwB;EAExBC,YAAYC,UAAyC,CAAC,GAAG;AACrDC,WAAOC,OAAO,MAAM;MAChBT,aAAaO,QAAQP;MACrBC,OAAOM,QAAQN;MACfC,OAAOK,QAAQL;MACfC,eAAeI,QAAQJ;MACvBC,eAAeG,QAAQH;MACvBC,eAAeK,OAAOH,QAAQF,aAAa,KAAK;IACpD,CAAA;EACJ;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;AAGO,IAAMM,gBACb;;;;;;;AAQO,IAAMC,oBAAN,MAAMA;SAAAA;;;EAETC;EAEAC;EAEAC;EAEAC;EAEAC;EAEAC;EAEAC;EAEAb,YAAYC,UAAsC,CAAC,GAAG;AAClDC,WAAOC,OAAO,MAAMF,OAAAA;EACxB;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGO,IAAMa,mBACb;;;;;;;;;AAWA,IAAA,8BAAe;EACXC,MAAK;EACLC,SAAS;IAAC;IAAuB;IAA2B;;EAC5DC,UAAU,8BAAMC,SAAwBC,YAAAA;AACpCC,wBAAoBC,KAAK,+BAA+BF,QAAQG,MAAM;AACtE,UAAMC,qBAAqBL,OAAAA;AAC3B,WAAO;EACX,GAJU;EAKVM,aAAY;EACZC,SAAS,8BAAOP,SAAuBC,SAAgBO,OAAaC,UAChEC,aAAAA;AACA,QAAI;AACAR,0BAAoBC,KAAK,qCAAqCF,QAAQG,MAAM;AAE5E,YAAMO,gBAAgBX,QAAQY,WAAW,gBAAA;AAEzCD,oBAAcE,WAAWb,OAAAA;AAEzBQ,cAAS,MAAMR,QAAQc,aAAab,SAAQ;QAACc,eAAeC,gBAAgBC,mBAAmB1C,oBAAAA;MAAqB,CAAA;AAEpH,YAAM2C,UAAUC,eAAe;QAACX;QAAMY,UAASjC;MAAa,CAAA;AAE5D,YAAMkC,UAAU,MAAMC,yBAAyB;QAC3CtB;QACAkB;QACAK,YAAYC,WAAWC;MAC3B,CAAA;AAEA,YAAMC,UAA+B,IAAInD,qBAAqB8C,OAAAA;AAI9DZ,iBAAW;QAACkB,aAAYD,QAAQ9C;MAAa;AAK7C,YAAMgD,YAAY,MAAMjB,cAAckB,aAAa,GAAGH,QAAQ7C,aAAa;AAE3E,YAAMiD,iBAAiB,IAAIC,gBAAgB/B,QAAQgC,WAAW,gBAAA,GAA4BhC,OAAAA;AAE1F,YAAMiC,uBAAuB,MAAMH,eAAeI,sBAAsB;QAACP,aAAYD,QAAQ9C;QAAegD;QAAWjD,eAAc+C,QAAQ/C;MAAa,CAAA;AAE1J,UAAIsD,qBAAqBE,MAAK,GAAG;AAEzB,YAAGzB,UAAS;AACRA,mBAAS;YACL0B,MAAK,gCAAgCH,qBAAqBI,OAAM,EAAGpC,OAAO;YAC1EoB,SAAQ;cAACiB,OAAML,qBAAqBI,OAAM,EAAGpC;YAAO;UACxD,CAAA;QACJ;AACA,eAAO;MAEf;AAEAO,cAAS,MAAMR,QAAQc,aAAab,SAAQ;QAACxB,OAAMiD,QAAQjD;QAAMC,OAAMgD,QAAQhD;QAAMqC,eAAeC,gBAAgBC,mBAAmB7B,iBAAAA;MAAkB,CAAA;AAGzJ,YAAMmD,2BAA2BpB,eAAe;QAACX;QAAMY,UAASxB;MAAgB,CAAA;AAEhF,YAAM4C,2BAA2B,MAAMlB,yBAAyB;QAC5DtB;QACAkB,SAASqB;QACThB,YAAYC,WAAWC;MAC3B,CAAA;AAEA,YAAMgB,2BAA8C,IAAIrD,kBAAkBoD,wBAAAA;AAE1E,YAAME,oBAAqB,MAAMC,cAAc;QAC3CC,QAAQH,yBAAyBpD;QACjCwD,OAAO;QACPC,QAAQ;QACRC,OAAO;MACX,GAAG/C,OAAAA,GAA2BgD,KAAK,CAAA;AAGnC,YAAM,EAACC,QAAOC,kBAAkBC,WAAUC,oBAAmB,IAAIC,sBAAsBX,gBAAAA;AAEvF,YAAMY,kBAAkB,MAAMX,cAAc;QACxCC,QAAQH,yBAAyBjD;QACjCqD,OAAO;QACPC,QAAQ;QACRC,OAAO;MACX,GAAG/C,OAAAA,GAA2BgD,KAAK,CAAA;AAEnC,YAAM,EAACC,QAAOM,gBAAgBJ,WAAUK,kBAAiB,IAAIH,sBAAsBC,cAAAA;AAGnF,UAAG5C,UAAS;AACRA,iBAAS;UACL0B,MAAK;QACT,CAAA;MACJ;AAGA,YAAMqB,gBAAiB,MAAMC,cAAc;QACvCnE,QAAQkD,yBAAyBlD;MACrC,GAAGS,OAAAA;AAEH,UAAIyD,cAActB,MAAK,GAAG;AACtB,YAAGzB,UAAS;AACRA,mBAAS;YACL0B,MAAK,4BAA4BqB,cAAcpB,OAAM,EAAGpC,OAAO;YAC/DoB,SAAQ;cAACiB,OAAMmB,cAAcpB,OAAM,EAAGpC;YAAO;UACjD,CAAA;QACJ;AACA,eAAO;MACX;AAGA,UAAGS,UAAS;AACRA,iBAAS;UACL0B,MAAK;QACT,CAAA;MACJ;AAEA,YAAMuB,cAAcF,cAAcG,OAAM;AAGxCjD,oBAAckD,mBAAmB;QAC7BC,OAAM;UACFd,MAAKW;UACLI,UAAS;YACLC,QAAQ;YACRvF,OAAOiD,QAAQjD;YACfwF,OAAOxB,yBAAyB9C;YAChCuE,UAAUxC,QAAQhD;UACtB;UACAyF,OAAOjB;UACPkB,gBAAehB;QACnB;MACJ,CAAA;AAEA,YAAMiB,qBAAqB1D,cAAc2D,uBAAuB;QAC5DC,WAAUhB;QACVJ,WAAUK;MACd,CAAA;AAIA,UAAG9C,UAAS;AACRA,iBAAS;UACL0B,MAAK;QACT,CAAA;MACJ;AAGA,YAAMoC,eAAe,MAAM7D,cAAc8D,yBAAyB;QAC9DC,UAAS;UACL7E,MAAK,GAAG6B,QAAQjD,KAAK,IAAIiD,QAAQlD,WAAW;UAC5CmG,SAAS;QACb;QACAC,WAAU;QACVC,KAAI;UACAC,WAAU,MAAMrC,yBAAyB/C,OAAO;UAChDqF,sBAAqB;UACrBC,UAAU9F,OAAOwC,QAAQ7C,aAAa;UACtCgB,MAAK,SAAS4C,yBAAyB/C,OAAO;UAC9CY,aAAYmC,yBAAyBhD;QACzC;QACA8E,WAAU;UACNU,eAAcZ;QAClB;QACAM,SAASjD,QAAQ/C;MACrB,CAAA;AAIA,UAAI6F,aAAaU,SAAQ;AACrB,YAAGxE,UAAS;AACRA,mBAAS;YACL0B,MAAK,uCAAuCV,QAAQ7C,aAAa,oCAAoC2F,aAAaW,QAAQ;YAC1H9D,SAAQ;cAAC6D,SAAQ;YAAI;UACzB,CAAA;QACJ;MACJ;AACA,aAAO;IACX,SAAS5C,OAAO;AAEZ,YAAMR,iBAAiB,IAAIC,gBAAgB/B,QAAQgC,WAAW,gBAAA,GAA4BhC,OAAAA;AAE1F,YAAMoF,iBAAiB,MAAMtD,eAAeuD,cAAc5E,SAASkB,WAAW;AAE9E,UAAIyD,eAAejD,MAAK,GAAG;AACvBjC,4BAAoBoC,MAAM,+BAA+B8C,eAAe/C,OAAM,CAAA;MAClF;AAEAnC,0BAAoBoC,MAAM,gCAAgCA,KAAAA;AAC1D,UAAI5B,UAAU;AACVA,iBAAS;UACL0B,MAAM,qCAAqCE,MAAMrC,OAAO;UACxDoB,SAAS;YAAEiB,OAAOA,MAAMrC;UAAQ;QACpC,CAAA;MACJ;AACA,aAAO;IACX;EACJ,GA3LS;EA4LTqF,UAAS;IACD;MACI;QACIC,MAAK;QACLlE,SAAQ;UACJe,MAAK;QACT;MACJ;MACA;QACImD,MAAK;QACLlE,SAAQ;UACJe,MAAK;UACLoD,QAAO;QACX;MACJ;;;AAGhB;;;AKzSO,IAAMC,sBAA8B;EACvCC,MAAM;EACNC,aACI;EACJC,SAAS;IAACC;;EACVC,WAAW,CAAA;EACXC,YAAY,CAAA;EACZC,UAAU;IAAC,IAAIC,cAAAA;;EACfC,SAAS,CAAA;AACb;;;ACTA,cAAe;AAEf,IAAA,gBAAeC;","names":["Service","Connection","Keypair","AithraManager","bs58","fs","os","path","AithraService","Service","manager","connection","keypair","basePath","items","constructor","getBasePath","removeAndCreateAssetsFolder","assetsPath","join","fs","rmSync","recursive","force","mkdirSync","folder","readTrackInfo","infoPath","existsSync","existingInfo","readFileSync","JSON","parse","writeTrackInfo","trackInfo","writeFileSync","stringify","createTempFolderStructure","err","console","error","serviceType","getTotalCost","numberOfSongs","numberOfMints","response","isOk","unwrap","initialize","runtime","Connection","getSetting","privateKey","Error","Keypair","fromSecretKey","bs58","decode","AithraManager","priorityFee","Number","process","env","AITHRA_PRIORITY_FEE","resolve","tmpdir","buildUploadMintMusicNFTs","params","result","folderPath","storeBufferToFile","buffer","subFolder","fileName","filePath","saveTrackData","trackData","trackMetadata","trackNumber","push","metadata","storeTrackToFolder","track","data","image","imageExtension","storeTracksToFolder","i","tracks","length","storeAnimationToFolder","animation","extension","composeContext","generateImage","generateObjectDeprecated","ModelClass","Replicate","Result","SchemaField","constructor","type","description","Description","target","propertyKey","Reflect","defineMetadata","SchemaGenerator","generateJSONSchema","classType","schema","parseClass","convertToPrompt","instance","prototype","Object","getPrototypeOf","key","keys","getMetadata","actualValue","typeString","Array","isArray","isNestedObject","parseNestedObject","getTypeString","value","length","obj","result","entries","typeName","name","toLowerCase","prompt","forEach","field","indent","includes","convertBase64ToBuffer","base64String","base64Data","replace","extension","split","buffer","Buffer","from","generateAudio","lyrics","referenceAudioUrl","runtime","replicate","Replicate","auth","getSetting","input","bitrate","song_file","sample_rate","response","run","ReadableStream","reader","getReader","chunks","done","read","push","audioBuffer","concat","map","chunk","Result","ok","err","Error","error","aithraToolkitLogger","z","aithraEnvSchema","z","object","SOLANA_RPC_URL","string","min","AITHRA_PRIVATE_KEY","AITHRA_PRIORITY_FEE","number","validateAithraConfig","runtime","config","getSetting","process","env","Number","parse","error","ZodError","errorMessages","errors","map","err","path","join","message","Error","Connection","PublicKey","Keypair","getAssociatedTokenAddressSync","CacheStorage","runtime","cacheKey","compareFunction","constructor","a","b","setValue","key","value","console","warn","cacheManager","set","getValue","get","append","cached","getAll","valuesToAdd","Array","isArray","forEach","item","some","existingItem","push","remove","filtered","filter","clear","PaymentsStorage","storage","hashesStorage","PAYMENT_PREFIX","checkPaymentExists","hash","setPayment","payment","getPayment","deletePayment","Result","bs58","TransactionNotFoundError","Error","constructor","TransferInstructionNotFoundError","PaymentsService","rpcUrl","paymentsStorage","AITHRA_MINT","PublicKey","walletPublicKey","runtime","PaymentsStorage","privateKey","getSetting","keypair","Keypair","fromSecretKey","bs58","decode","publicKey","toBase58","getSolTransferDetails","tx","connection","Connection","transaction","getParsedTransaction","maxSupportedTransactionVersion","meta","err","Result","instructions","message","transferInstruction","find","instruction","program","parsed","type","info","ok","receiver","destination","sender","source","amount","Number","lamports","toString","error","String","getSplTransferDetails","tokenAmount","uiAmount","verifyEligiblePayment","params","paymentHash","totalCost","walletAddress","slippage","totalCostWithSlippage","isInUse","getPayment","solResult","isOk","unwrap","priceResult","getAithraPriceInSol","isErr","getErr","aithraPriceInSol","totalCostInSol","setPayment","hash","date","Date","toISOString","from","to","splResult","sourceAta","getAssociatedTokenAddressSync","receiverAta","deletePayment","tokenData","fetch","json","data","price","MusicPlaylistDetails","releaseType","title","style","walletAddress","paymentTxHash","numberOfMints","constructor","partial","Object","assign","Number","extractPrompt","GenerativePrompts","coverImagePrompt","audioPrompt","lyrics","nftCoverImagePrompt","nftDescription","nftName","albumTitle","generativePrompt","name","similes","validate","runtime","message","aithraToolkitLogger","info","userId","validateAithraConfig","description","handler","state","_options","callback","aithraService","getService","initialize","composeState","output_format","SchemaGenerator","generateJSONSchema","context","composeContext","template","content","generateObjectDeprecated","modelClass","ModelClass","LARGE","payload","paymentHash","totalCost","getTotalCost","paymentService","PaymentsService","getSetting","paymentCheckResponse","verifyEligiblePayment","isErr","text","getErr","error","generativePromptsContext","generativePromptsContent","generativePromptsPayload","coverImageBase64","generateImage","prompt","width","height","count","data","buffer","coverImageBuffer","extension","coverImageExtension","convertBase64ToBuffer","nftImageBase64","nftImageBuffer","nftImageExtension","trackResponse","generateAudio","trackBuffer","unwrap","storeTrackToFolder","track","metadata","artist","album","category","image","imageExtension","animationMediaPath","storeAnimationToFolder","animation","mintResponse","buildUploadMintMusicNFTs","playlist","creator","tokenCode","nft","tokenName","sellerFeeBasisPoints","quantity","animationFile","success","assetIds","removeResponse","deletePayment","examples","user","action","aithraToolkitPlugin","name","description","actions","createMusicPlaylist","providers","evaluators","services","AithraService","clients","aithraToolkitPlugin"]}