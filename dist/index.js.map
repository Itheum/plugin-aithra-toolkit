{"version":3,"sources":["../src/services/aithraService.ts","../src/plugins/aithraToolkitPlugin.ts","../src/index.ts"],"sourcesContent":["import {\n    IAgentRuntime,\n    Service,\n    ServiceType,\n} from \"@elizaos/core\";\nimport { Connection, Keypair } from \"@solana/web3.js\";\nimport { AithraManager, TrackInfo } from \"@aithranetwork/sdk-aithra-toolkit\";\nimport bs58 from \"bs58\";\nimport * as fs from \"fs\";\nimport * as os from \"os\";\nimport * as path from \"path\";\n\nexport class AithraService extends Service {\n    private manager: AithraManager;\n    private connection: Connection;\n    private keypair: Keypair;\n    private basePath: string;\n    private items = 0;\n\n    constructor() {\n        super();\n    }\n\n    getBasePath(): string {\n        return this.basePath;\n    }\n\n    private removeAndCreateAssetsFolder(): void {\n        const assetsPath = path.join(this.basePath, \"assets\");\n        fs.rmSync(assetsPath, { recursive: true, force: true });\n        fs.mkdirSync(assetsPath, { recursive: true });\n        for (const folder of [\"audio\", \"images\"]) {\n            fs.mkdirSync(path.join(assetsPath, folder), { recursive: true });\n        }\n    }\n\n    private readTrackInfo(): TrackInfo {\n        const infoPath = path.join(this.basePath, \"assets\", \"info.json\");\n        if (!fs.existsSync(infoPath)) return [];\n        const existingInfo = fs.readFileSync(infoPath, \"utf8\");\n        return JSON.parse(existingInfo) as TrackInfo;\n    }\n\n    private writeTrackInfo(trackInfo: TrackInfo): void {\n        const infoPath = path.join(this.basePath, \"assets\", \"info.json\");\n        fs.writeFileSync(infoPath, JSON.stringify(trackInfo, null, 2));\n    }\n\n    private createTempFolderStructure(): void {\n        try {\n            this.removeAndCreateAssetsFolder();\n        } catch (err) {\n            console.error(\"Failed to create assets folder structure:\", err);\n        }\n    }\n\n    static get serviceType() {\n        return \"aithra_toolkit\" as ServiceType;\n    }\n\n    async initialize(runtime: IAgentRuntime, basePath?: string): Promise<void> {\n        this.connection = new Connection(\n            runtime.getSetting(\"SOLANA_RPC_URL\") ||\n                \"https://api.mainnet-beta.solana.com\",\n            \"confirmed\"\n        );\n\n        const privateKey = runtime.getSetting(\"AITHRA_PRIVATE_KEY\");\n        if (!privateKey) {\n            throw new Error(\n                \"AITHRA_PRIVATE_KEY environment variable is required\"\n            );\n        }\n\n        this.keypair = Keypair.fromSecretKey(bs58.decode(privateKey));\n\n        // Initialize the AithraManager\n        this.manager = new AithraManager({\n            connection: this.connection,\n            keypair: this.keypair,\n            priorityFee:\n                Number(runtime.getSetting(\"AITHRA_PRIORITY_FEE\")) ||\n                Number(process.env.AITHRA_PRIORITY_FEE) ||\n                0,\n        });\n\n        this.basePath = path.resolve(\n            basePath || path.join(os.tmpdir(), \"aithra-temp\")\n        );\n\n        this.createTempFolderStructure();\n    }\n\n    async buildUploadMintMusicNFTs(params: {\n        playlist: {\n            name: string;\n            creator: string;\n        };\n        tokenCode: \"MUSIC\";\n        nft: {\n            tokenName: string;\n            sellerFeeBasisPoints: number;\n            quantity: number;\n            name: string;\n            description: string;\n        };\n        animation: {\n            animationFile: string;\n        };\n    }) {\n        try {\n            const result = await this.manager.buildUploadMintMusicNFTs({\n                folderPath: path.join(this.basePath, \"assets\"),\n                ...params,\n            });\n\n            fs.rmSync(path.join(this.basePath, \"assets\"), {\n                recursive: true,\n                force: true,\n            });\n            return result;\n        } catch (error) {\n            console.error(\"Failed to upload music NFTs:\", error);\n            throw error;\n        }\n    }\n\n    private storeBufferToFile(\n        buffer: Buffer,\n        subFolder: string,\n        fileName: string\n    ): string {\n        const filePath = path.join(\n            this.basePath,\n            \"assets\",\n            subFolder,\n            fileName\n        );\n        fs.writeFileSync(filePath, buffer);\n        return filePath;\n    }\n\n    private saveTrackData(\n        trackData: Buffer,\n        trackMetadata: {\n            artist: string;\n            album: string;\n            title: string;\n            category: string;\n        },\n        trackNumber: number\n    ): void {\n        this.storeBufferToFile(trackData, \"audio\", `track${trackNumber}.mp3`);\n        let trackInfo = this.readTrackInfo();\n        trackInfo.push({\n            [`track${trackNumber}`]: { metadata: trackMetadata },\n        });\n        this.writeTrackInfo(trackInfo);\n    }\n\n    storeTrackToFolder(params: {\n        track: {\n            data: Buffer;\n            metadata: {\n                artist: string;\n                album: string;\n                title: string;\n                category: string;\n            };\n            image: Buffer;\n        };\n    }): void {\n        this.items += 1;\n        this.saveTrackData(\n            params.track.data,\n            params.track.metadata,\n            this.items\n        );\n\n        if (params.track.image) {\n            this.storeBufferToFile(\n                params.track.image,\n                \"images\",\n                `track${this.items}_cover.jpg`\n            );\n        }\n    }\n\n    storeTracksToFolder(params: {\n        tracks: Array<{\n            data: Buffer;\n            metadata: {\n                artist: string;\n                album: string;\n                title: string;\n                category: string;\n            };\n            image: Buffer;\n        }>;\n    }): void {\n        for (let i = 0; i < params.tracks.length; i++) {\n            this.storeTrackToFolder({\n                track: params.tracks[i],\n            });\n        }\n    }\n\n    storeAnimationToFolder(params: {\n        animation: Buffer;\n        extension?: string;\n    }): string {\n        return this.storeBufferToFile(\n            params.animation,\n            \"\",\n            `animation.${params.extension || \"png\"}`\n        );\n    }\n}\n","import { Plugin } from \"@elizaos/core\";\nimport { AithraService } from \"../services/aithraService\";\n\nexport const aithraToolkitPlugin: Plugin = {\n    name: \"aithra-toolkit\",\n    description:\n        \"A simple toolkit enabling agents to tokenize any data with a few lines of code\",\n    actions: [],\n    providers: [],\n    evaluators: [],\n    services: [new AithraService()],\n    clients: [],\n};\n","import { aithraToolkitPlugin } from \"./plugins/aithraToolkitPlugin\";\n\nexport * from \"./plugins/aithraToolkitPlugin\";\nexport * from \"./services/aithraService\";\nexport * from  \"@aithranetwork/sdk-aithra-toolkit\";\n\nexport default aithraToolkitPlugin;\n"],"mappings":"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","names":[]}